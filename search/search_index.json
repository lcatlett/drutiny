{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Drutiny - automated site auditing","text":"<p>A generic Drupal site auditing and optional remediation tool.</p>"},{"location":"#installation","title":"Installation","text":"<p>This repository is a baseline framework and not recommended to install by itself unless you're planning on building your own auditing tool based on top of Drutiny.</p> <p>You can install Drutiny into your project with composer.</p> <pre><code>composer require drutiny/drutiny ^3.6.0\n</code></pre> <p>Drutiny has native target support for Git and Drush. If you wish to use these types of targets, you must install the underlying software.</p>"},{"location":"#usage","title":"Usage","text":"<p>Drutiny is a command line tool that can be called from the composer vendor bin directory:</p> <pre><code>./vendor/bin/drutiny\n</code></pre>"},{"location":"#finding-targets-to-audit","title":"Finding targets to audit","text":"<p>Drutiny has a number of connectors that allow you to discover and access \"Targets\" to audit. Use the <code>target:sources</code> command to learn which sources are available.</p> <pre><code>./vendor/bin/drutiny target:sources\n</code></pre> <p>When supported by the target source, use the <code>target:list</code> command to list all the available targets from a given source:</p> <pre><code># List all available targets through DDEV.\n./vendor/bin/drutiny target:list ddev\n</code></pre>"},{"location":"#finding-policies-available-to-run","title":"Finding policies available to run","text":"<p>Drutiny comes with a <code>policy:list</code> command that lists all the policies available to audit against.</p> <pre><code>./vendor/bin/drutiny policy:list\n</code></pre> <p>Policies provided by other packages such as drutiny/plugin-distro-common will also appear here, if they are installed.</p>"},{"location":"#installing-drutiny-plugins","title":"Installing Drutiny Plugins","text":"<p>Additional Drutiny policies, audits, profiles and commands can be installed with composer.</p> <pre><code>$ composer search drutiny\n</code></pre> <p>Official Drutiny plugins include:</p> <ul> <li>Acquia</li> <li>Pantheon</li> <li>Sumologic</li> <li>Cloudflare</li> <li>CodeClimate Engine</li> <li>jUnit</li> <li>Domo</li> </ul> <p>Inside Drutiny core (this repository) is native support for Drush, DDEV, Lando and Docksal.</p>"},{"location":"#running-an-audit","title":"Running an Audit","text":"<p>An audit of a single policy can be run against a site by using <code>policy:audit</code> and passing the policy name and site target:</p> <pre><code>./vendor/bin/drutiny policy:audit Drupal-8:PageCacheExpiry @drupalvm.dev\n</code></pre> <p>The command above would audit the site that resolved to the <code>@drupalvm.dev</code> drush alias against the <code>Drupal-8:PageCacheExpiry</code> policy.</p> <p>Some policies have parameters you can specify which can be passed in at call time. Use <code>policy:info</code> to find out more about the parameters available for a check.</p> <pre><code>./vendor/bin/drutiny policy:audit -p value=600 Drupal-8:PageCacheExpiry @drupalvm.dev\n</code></pre> <p>Audits are self-contained classes that are simple to read and understand. Policies are simple YAML files that determine how to use Audit classes. Therefore, Drutiny can be extended very easily to audit for your own unique requirements. Pull requests are welcome as well, please see the contributing guide.</p>"},{"location":"#running-a-profile-of-checks","title":"Running a profile of checks","text":"<p>A site audit is running a collection of checks that make up a profile. This allows you to audit against a specific standard, policy or best practice. Drutiny comes with some base profiles which you can find using <code>profile:list</code>. You can run a profile with <code>profile:run</code> in a simlar format to <code>policy:audit</code>.</p> <pre><code>./vendor/bin/drutiny profile:run d8 @drupalvm.dev\n</code></pre> <p>Parameters can not be passed in at runtime for profiles but are instead predefined by the profile itself.</p>"},{"location":"#getting-help","title":"Getting help","text":"<p>Because this is a Symfony Console application, you have some other familiar commands:</p> <pre><code>./vendor/bin/drutiny help profile:run\n</code></pre> <p>In particular, if you use the <code>-vvv</code> argument, then you will see all the drush commands, and SSH commands printed to the screen.</p>"},{"location":"#credits","title":"Credits","text":"<ul> <li>Theodoros Ploumis for creating the logo for Drutiny.</li> </ul>"},{"location":"Develop/Audit/Dependencies/","title":"Dependencies","text":"<p>Audit dependencies are optional attributes that allow your audit class to depend on conditions that qualify the policy using your audit class.</p> <pre><code>&lt;?php\n\nnamespace Demo\\CustomDrutinyProject\\Audit;\n\nuse Drutiny\\Audit\\AbstractAnalysis;\nuse Drutiny\\Policy\\Dependency;\n\n#[Dependency(\n    expression: 'Drupal.isVersion10orLater',\n    on_fail: 'omit'\n)]\nclass ProjectDataGatherer extends AbstractAnalysis {\n\n    protected function gather() {\n        $this-&gt;set('foo', 'bar');\n    }\n}\n</code></pre> <p>In the above example, the audit class requires the Target being audited is Drupal 10 or later instance. This is determined by the metadata preloaded onto the Target before the audit is executed.</p>"},{"location":"Develop/Audit/Dependencies/#expression","title":"Expression","text":"<p>The expression field must evaluate to true to satisfy the dependency. If it doesn't, the the <code>on_fail</code> behaviour is executed. The expression is a string that will evaluate Twig syntax.</p> <p>To find a list of available expressions flags to use, see <code>drutiny expression:reference</code> command.</p>"},{"location":"Develop/Audit/Dependencies/#requiring-a-type-of-target","title":"Requiring a type of Target","text":"<p>If your audit class is only suitable for certain types of Targets, you can use the <code>Target.typeOf</code> flag in your expression where the value passed is the name of a target source found in the <code>drutiny target:sources</code> command.</p> <pre><code>&lt;?php\n\n// Ensure the target is a \"drush\" target type.\n#[Dependency(\n    expression: 'Target.typeOf(\"drush\")',\n    on_fail: 'omit'\n)]\n</code></pre> <p>Note: the <code>Target.typeOf</code> check respects class inheritence and Targets extending the type you're testing for will pass the check also.</p>"},{"location":"Develop/Audit/Dependencies/#on-fail-behaviour","title":"On Fail behaviour","text":"<p>On fail behaviours are the same as those defined in policies.</p>"},{"location":"Develop/Audit/Dependencies/#behaviour-types","title":"Behaviour types","text":"Type Behaviour <code>omit</code> Omit policy from report <code>fail</code> Fail policy in report <code>error</code> Report policy as error <code>report_only</code> Report as not applicable <p>Note: If you cannot define a correct fail behaviour, it may suggest the dependency is better of defined in the policy rather than the audit.</p> <p>The default behaviour is not specified is to <code>fail</code>.</p> <p>Behaviours can be set by providing the <code>on_fail</code> argument to the Dependency attribute.</p> <pre><code>&lt;?php\n\n// Ensure the target is a \"drush\" target type.\n#[Dependency(\n    expression: 'Target.typeOf(\"drush\")',\n    on_fail: 'error'\n)]\n</code></pre>"},{"location":"Develop/Audit/GettingStarted/","title":"Getting started","text":""},{"location":"Develop/Audit/GettingStarted/#creating-your-own-audit-classes","title":"Creating your own audit classes","text":"<p>Audit classes gather data for policies to use and evaluate. Providing your own audit classes allows you to build custom policies that can assess the data your audit classes gather.</p>"},{"location":"Develop/Audit/GettingStarted/#creating-your-first-audit-class","title":"Creating your first audit class","text":""},{"location":"Develop/Audit/GettingStarted/#setup","title":"Setup","text":"<p>Before you start, you should have these pre-requisites in place:</p> <ul> <li>A knowledge of PHP object-oriented programing from version PHP 8.1 or later.</li> <li>A PHP project built with composer and using PSR-4 autoloading.</li> <li>The drutiny/drutiny composer package added to your project.</li> </ul> <p>For the purposes of this tutorial, we'll use a simple composer.json build like this:</p> <p><pre><code>{\n  \"name\": \"demo/custom-drutiny-project\",\n  \"type\": \"project\",\n  \"prefer-stable\": true,\n  \"description\": \"Scaffold composer file for learning to build drutiny audit classes.\",\n  \"require\": {\n    \"drutiny/drutiny\": \"^3.6.0\",\n  },\n  \"autoload\": {\n      \"psr-4\": {\n          \"Demo\\\\CustomDrutinyProject\\\\\": \"src/\",\n      }\n  },\n}\n</code></pre> Note this means the <code>Demo\\CustomDrutinyProject</code> namespace will autoload from php files located in  the <code>src</code> directory.</p>"},{"location":"Develop/Audit/GettingStarted/#writing-your-first-audit-class","title":"Writing your first audit class","text":"<p>Lets create an audit class called <code>ProjectDataGatherer</code> located in <code>src/Audit/ProjectDataGatherer.php</code> with these contents:</p> <pre><code>&lt;?php\n\nnamespace Demo\\CustomDrutinyProject\\Audit;\n\nuse Drutiny\\Audit\\AbstractAnalysis;\n\nclass ProjectDataGatherer extends AbstractAnalysis {\n\n    protected function gather() {\n        $this-&gt;set('foo', 'bar');\n    }\n}\n</code></pre> <p>The above audit class will gather the data ('bar') and set it to a token called 'foo'.</p> <p>Now we can use this class with drutiny's <code>audit:run</code> command:</p> <pre><code>drutiny audit:run 'Demo\\CustomDrutinyProject\\Audit\\ProjectDataGatherer' none:none\n</code></pre>"},{"location":"Develop/Audit/GettingStarted/#linking-your-class-up-to-a-policy","title":"Linking your class up to a policy","text":"<p>The above command runs the audit class against a null target ('none:none'). Typically you have to audit policies against targets but using this command, a policy is fabricated for you. Not much will happen in this run. To see a bit more, have to build a policy ourselves.</p> <p>Lets create a policy located in <code>policy/customDemo.policy.yml</code>.</p> <pre><code>title: Custom policy for evaluating project data\nname: custom:fooIsBar\nclass: Demo\\CustomDrutinyProject\\Audit\\ProjectDataGatherer\ndescription: Ensure that the foo token contains the value 'bar'.\nparameters:\n    failIf: foo != 'bar'\nsuccess: The token 'foo' contains the value 'bar'\nfailure: The token 'foo' does not contain the value 'bar'. Found \"{{ foo }}\" instead.\n</code></pre> <p>Using <code>drutiny policy:list</code> you should not be able to see your policy in the list of available policies.</p> <p>The <code>class</code> field in YAML file determins which audit class to use.  The tokens set using the <code>set</code> method inside the <code>gather</code> method of the class are exposed as variables to the <code>parameters.failIf</code> field which is evaluated to true or false. If its true, then the failure  message is triggered, otherwise a success is triggered.</p> <p>Note: the <code>failIf</code> parameter is provided by the <code>AbstractAnalysis</code> audit class <code>ProjectDataGatherer</code>  is extended from.</p> <ul> <li>Learn more about Parameters</li> </ul> <p>Now with a policy in place, we can test the class through the policy:</p> <pre><code>drutiny policy:audit custom:fooIsBar none:none\n</code></pre> <p>Now you should see a successful outcome with the message: The token 'foo' contains the value 'bar'.</p>"},{"location":"Develop/Audit/GettingStarted/#testing-the-fail-condition","title":"Testing the fail condition","text":"<p>Now that the policy is passing, lets test what happens when the data outputs are different.  Lets update our <code>ProjectDataGatherer</code> class to set <code>foo</code> to a different value:</p> <pre><code>&lt;?php\n    protected function gather() {\n        $this-&gt;set('foo', 'baz');\n    }\n</code></pre> <p>Now when we run the <code>policy:audit</code> command again, it should fail and we should see the message:</p> <pre><code>The token 'foo' does not contain the value 'bar'. Found \"baz\" instead.\n</code></pre> <p>Here you can see Twig templating in action where the token <code>foo</code> was rendered in the <code>failure</code> message using the Twig syntax: <code>{{ foo }}</code>.</p>"},{"location":"Develop/Audit/GettingStarted/#dependency-injection","title":"Dependency Injection","text":"<p>The <code>gather</code> method is a special method in the class called to gather data. Sometimes data gathering requires use of other service objects that can be injected into the method by declaring them as parameters in the method definition.</p> <pre><code>&lt;?php\n\nnamespace Demo\\CustomDrutinyProject\\Audit;\n\nuse Drutiny\\Audit\\AbstractAnalysis;\nuse Demo\\CustomDrutinyProject\\MyCustomService;\n\nclass ProjectDataGatherer extends AbstractAnalysis {\n\n    protected function gather(MyCustomService $service) {\n        $this-&gt;set('value', $service-&gt;getValue());\n    }\n}\n</code></pre> <p>Here the service instance of <code>Demo\\CustomDrutinyProject\\MyCustomService</code> will be provided to the <code>gather</code> method so the object can be used to gather data.</p> <p>Note: The service class does need to be registered in the Service Container. This can be done by declaring it in your <code>drutiny.yml</code> file:</p> <pre><code>services:\n    Demo\\CustomDrutinyProject\\MyCustomService: ~\n</code></pre>"},{"location":"Develop/Audit/GettingStarted/#next-steps","title":"Next Steps","text":"<ul> <li>Learn more about Parameters</li> <li>Learn more about Dependencies</li> </ul>"},{"location":"Develop/Audit/Parameters/","title":"Parameters","text":"<p>Parameters allow you to delcare inputs that a policy can provide to your audit class. These inputs are typically to instruct data gathering. For example:</p> <ul> <li>A query string for gathering data from queriable locations (e.g. APIs, Databases, etc)</li> <li>Limits and other flags to conduct the audit behaviour.</li> </ul> <p>Parameters are declared using PHP Attributes on the Class declaration.</p> <pre><code>&lt;?php\n\nnamespace Demo\\CustomDrutinyProject\\Audit;\n\nuse Drutiny\\Attribute\\Parameter;\nuse Drutiny\\Attribute\\Type;\nuse Drutiny\\Audit\\AbstractAnalysis;\nuse Drutiny\\Audit\\DynamicParameterType;\n\n#[Parameter(\n    name: 'multiplier', \n    default: 1,\n    type: Type::INTEGER,\n    enums: [1,2,3,4,5,6,7,8,9,10],\n    description: 'A multiplier between 1 and 10.',\n    mode: Parameter::REQUIRED,\n    preprocess: DynamicParameterType::EVALUATE,\n)]\nclass ProjectDataGatherer extends AbstractAnalysis {\n\n    protected function gather() {\n        $this-&gt;set('value', 4 * $this-&gt;getParameter('multiplier'));\n    }\n}\n</code></pre> <p>In the example above a parameter called <code>multiplier</code> is declared that has a default value of <code>1</code>. The value set by the policy must be an <code>integer</code> between <code>1</code> and <code>10</code> and it must be provided. The parameter is then multipled by 4 and the result set as a token called <code>value</code> which a policy can use in its evaluation of outcome or messaging.</p> <p>Only <code>name</code> and <code>description</code> are required properties.</p> <p>Note: <code>default</code> values are only useful for optional parameters but are displayed here to show a fullness of possibilities.</p> <p>In the <code>gather</code> method, parameters can be retrieved using the <code>getParameter</code> method.</p>"},{"location":"Develop/Audit/Parameters/#setting-parameter-type","title":"Setting Parameter Type","text":"<p>There are several parameters types you can use to enforce strict type data passing from policies to audit classes.</p> Type Example Description <code>Type::BOOLEAN</code> <code>true</code> A true or false value <code>Type::INTEGER</code> <code>3</code> A positive or negative number <code>Type::FLOAT</code> <code>3.4</code> A decimal number <code>Type::STRING</code> <code>'foo'</code> A string of characters <code>Type::ARRAY</code> <code>['a', 'b']</code> A numerically sequential list of items. <code>Type::HASH</code> <code>['a' =&gt; 1, 'b' =&gt; 2]</code> A keyed list of items. <p>Note: In PHP terminology, a hash can be an associative array or an object.</p> <p>Types are set using the <code>type</code> argument in the Parameter declaration.</p> <pre><code>&lt;?php\n\nuse Drutiny\\Attribute\\Type;\nuse Drutiny\\Attribute\\Parameter;\n\n#[Parameter(\n    name: 'format',\n    description: 'Which format to return a result in.',\n    type: Type::STRING\n)]\n</code></pre> <p>Note: the Type enum comes from <code>Drutiny\\Attribute\\Type</code>.</p>"},{"location":"Develop/Audit/Parameters/#enums","title":"Enums","text":"<p>Enums are a way to restrain parameter inputs to a specified list of items</p> <pre><code>&lt;?php\n#[Parameter(\n    name: 'format',\n    description: 'Which format to return a result in.',\n    enums: ['yaml', 'json', 'csv', 'raw']\n)]\n</code></pre> <p>When using enums, the <code>type</code> field is not required since the data input must be one of the already known enum values. If the policy provides a value outside the enum list, a parameter validation error will be thrown.</p>"},{"location":"Develop/Audit/Parameters/#default-values","title":"Default values","text":"<p>Parameters can provide default values when a value is not provided.</p> <pre><code>&lt;?php\n#[Parameter(\n    name: 'format',\n    description: 'Which format to return a result in.',\n    enums: ['yaml', 'json', 'csv', 'raw'],\n    default: 'json'\n)]\n</code></pre> <p>This allows policies to not have to explicitly specify every available parameter in an audit class. It also works well when building audit classes ontop of existing audit classes.</p>"},{"location":"Develop/Audit/Parameters/#runtime-default-values","title":"Runtime default values","text":"<p>If you prefer to determine a default value at runtime, you can pass it as the second argument to the <code>getParameter</code> method.</p> <pre><code>&lt;?php\n\nnamespace Demo\\CustomDrutinyProject\\Audit;\n\nuse Drutiny\\Attribute\\Parameter;\nuse Drutiny\\Attribute\\Type;\nuse Drutiny\\Audit\\AbstractAnalysis;\n\n#[Parameter(\n    name: 'format',\n    description: 'Which format to return a result in.',\n    enums: ['yaml', 'json', 'csv', 'raw'],\n)]\nclass ProjectDataGatherer extends AbstractAnalysis {\n\n    protected function gather() {\n        //...\n        // Use the format defined by the policy or 'json' if none is provided.\n        $format = $this-&gt;getParameter('format', 'json');\n        //...\n    }\n}\n</code></pre>"},{"location":"Develop/Audit/Parameters/#making-parameters-required","title":"Making parameters required","text":"<p>By default a parameter is optional. However, you can set it as required by setting the parameter <code>mode</code>.</p> <pre><code>&lt;?php\n#[Parameter(\n    name: 'format',\n    description: 'Which format to return a result in.',\n    mode: Parameter::REQUIRED\n)]\n</code></pre> <p>Using the <code>Parameter::REQUIRED</code> constant as the <code>mode</code> value will ensure the policy provides this parameter beforce the audit data gathering can take place by the audit class.</p>"},{"location":"Develop/Audit/Parameters/#dynamic-parameters","title":"Dynamic Parameters","text":"<p>Dynamic parameters allow policies to use various syntax forms to evaluate and replace  parameter data on-the-fly. Read more about Dynamic Parameters in policies.</p> <p>In Audit class declarations, you can specify a <code>preprocess</code> property in the <code>Parameter</code> attribute which provides a default processing method.</p> <pre><code>&lt;?php\n\nuse Drutiny\\Audit\\DynamicParameterType;\n\n#[Parameter(\n    name: 'url',\n    description: 'The URL to make an HTTP request too.',\n    default: '{target.uri}',\n    preprocess: DynamicParameterType::REPLACE\n)]\n</code></pre> <p>The <code>preprocess</code> property requires an Enum called <code>Drutiny\\Audit\\DynamicParameterType</code>. It comes with 4 different types:</p> Value Purpose <code>Drutiny\\Audit\\DynamicParameterType::REPLACE</code> Replaces tokens found tightly wrapped in curly braces. <code>Drutiny\\Audit\\DynamicParameterType::EVALUATE</code> Evaluates the string through twig syntax. <code>Drutiny\\Audit\\DynamicParameterType::STATIC</code> Explicitly bypasses the value from dynamic processing. <code>Drutiny\\Audit\\DynamicParameterType::NONE</code> Has no set processing (default). <p>The preprocess property specifies the default preprocessing behaviour. However policies can still override the processing behaviour by specifying a process type with a syntax symbol at the begining of the parameter name. Read more about Dynamic Parameters in policies.</p>"},{"location":"Develop/Audit/Version/","title":"Version","text":"<p>Each audit class can be versioned so that policies can be built against  a specific version of an audit.</p> <p>Audit versions use semantic versioning and constraints as documented with Composer.</p>"},{"location":"Develop/Audit/Version/#add-a-version-to-your-audit-class","title":"Add a version to your audit class","text":"<p>To add a version to your audit class, we use the <code>Drutiny\\Attribute\\Version</code>  PHP attribute:</p> <pre><code>&lt;?php\n\nuse Drutiny\\Audit\\AbstractAnalysis;\nuse Drutiny\\Attribute\\Version;\n\n#[Version('1.0')]\nclass MyAuditClass extends AbstractAnalysis {\n\n}\n</code></pre> <p>When versioning your audit class, you should adhere to these principles of semantic versioning:</p> <ol> <li>Major increments (e.g. 1.0 --&gt; 2.0) are non backwards compatible.</li> <li>Minor increments (e.g. 1.0 --&gt; 1.1) introduce new features and are backwards compatible.</li> <li>Patch increments (e.g. 1.0.0 -&gt; 1.0.1) are for bug fixes and are backwards compatible.</li> </ol>"},{"location":"Develop/Audit/Version/#adding-compatibility-constraints","title":"Adding compatibility constraints","text":"<p>You can provide compatibility constraints to show that your audit class  supports a variety of versions.</p>"},{"location":"Develop/Audit/Version/#examples","title":"Examples","text":"<p><pre><code>#[Version('1.4', '^1.2')]\n</code></pre> This means the audit class is at version 1.4 however, it will support policies that were written in versions 1.2 or later.</p> <p><pre><code>#[Version('2.3', '^1.3 || ^2.0')]\n</code></pre> Version 2.3 supports policies using 2.0 or later or policies using version  1.3 or later in the 1.x branch of releases.</p> <p>For more information about adding version data to policies, see audit_build_info.</p>"},{"location":"Develop/Policy/DynamicParameters/","title":"Dynamic Parameters","text":"<p>Dynamic parameters are introduced in version 3.6.</p> <p>Dynamic parameters allow you to preprocess parameters before they are passed into an audit to be used to gather and evaluate data.</p> <p>Although processing only occurs on strings, hashes (associative arrays) will be traversed for deeper keys that which to utilise dynamic parameters.</p> <p>Dynamic parameters are declared by prefixing a parameter with a processing symbol. There are three symbols: <code>^</code>, <code>$</code> and <code>!</code>. When a dynamic parameter is processed, its prefixed symbol is removed.</p> <p>Lets learn what they do.</p>"},{"location":"Develop/Policy/DynamicParameters/#token-replacement-with-the-symbol","title":"Token replacement with the <code>^</code> symbol.","text":"<p>When the caret (<code>^</code>) prefixes a parameter name, that parameter value will  have token replacement (also called interpolation) processed over it.</p> <p>Tokens in strings are denoted with single curly braces tightly wrapped (no  spaces) around the token value.</p>"},{"location":"Develop/Policy/DynamicParameters/#example","title":"Example","text":"<p>Lets say we have a target with a domain value of <code>foo.site.com</code>. To use this value in a parameter with token replacement you would do this:</p> <pre><code>parameters:\n    ^query: errors=1 AND domain={target.domain}\n</code></pre> <p>After processing, the parameters would look like this:</p> <pre><code>parameters:\n    query: errors=1 AND domain=foo.site.com\n</code></pre> <p>Token replacement is useful when you don't want to over complicate a parameter with twig evaluative syntax. For example, parameters that use another language syntax maybe increase its complexity to use twig.</p> <p>Token replacement also works on embedded parameters:</p> <pre><code>parameters:\n    options: \n        ^filter: domain={target.domain}\n</code></pre>"},{"location":"Develop/Policy/DynamicParameters/#evaluated-parameters-with-the-symbol","title":"Evaluated parameters with the <code>$</code> symbol.","text":"<p>When the dollar symbol (<code>$</code>) prefixes a parameter name, that value will be evaluated and its result set as the parameter value.</p>"},{"location":"Develop/Policy/DynamicParameters/#example_1","title":"Example:","text":"<p>Using the same example as token replacement but using twig evaluation instead.</p> <pre><code>parameters:\n    $query: \"errors=1 AND domain=\" ~ target.domain\n</code></pre> <p>Here you might notice the <code>query</code> string is more visually disrupted by this  syntax. In this use case, token replacement is probably a better method.</p> <p>However, evaluated parameters are better suited for heavier work such as filtering results into new parameters.</p> <pre><code>parameters:\n    $zone: 'target[\"zone.list\"] is defined ? target[\"zone.list\"] | first : target.domain'\n</code></pre> <p>Here the <code>zone</code> parameter will be either the first value in an array from a target's  dynamic property list called <code>zone.list</code> or if that is not present, the target's domain property will be used.</p>"},{"location":"Develop/Policy/DynamicParameters/#static-parameters-with-the-symbol","title":"Static parameters with the <code>!</code> symbol.","text":"<p>When the asterisk (<code>!</code>) symbol prefixes a parameter value, it will force the parameter to be static rather than evaluated. This is primarily used for  <code>build_parameters</code> which are inheritly evaluated parameters with the need to denote them as such. Instead, build_parameters but be explicitly denoted as static or token replaced if they do not want to be evaluated.</p>"},{"location":"Develop/Policy/DynamicParameters/#example_2","title":"Example","text":"<pre><code>build_parameters:\n    '!options': \n        filter:\n            $version: target.version\n        limit: 20\n        sort: count \n</code></pre> <p>Normally, a build parameter must be a string to be evaluated. However here, the value can be statically provided. The static value can also be traversed and its  values processed as the <code>$version</code> key would be here.</p>"},{"location":"Develop/Policy/GettingStarted/","title":"Getting started","text":""},{"location":"Develop/Policy/GettingStarted/#creating-your-own-policies","title":"Creating your own policies","text":"<p>Policies are structured objects files that provide configuration and to power Drutiny's audit system. Polices are provided to Drutiny via Policy Sources.</p> <p>By default, Drutiny comes with one Policy Source: the local filesystem (using YAML). Additional plugins may provide more policies from other sources.</p>"},{"location":"Develop/Policy/GettingStarted/#getting-started-with-yaml-policies","title":"Getting started with YAML policies","text":"<p>You can create your own policies locally by using a pre-defined YAML schema and storing the policy in a YAML file with a .policy.yml file extension anywhere under the directory structure you call Drutiny within.</p>"},{"location":"Develop/Policy/GettingStarted/#downloading-an-existing-policy","title":"Downloading an existing policy.","text":"<p>A great way to start is to download an existing policy that might be similar to what you're interested in auditing. You can use the <code>policy:download</code> command to download a policy into the local filesystem. This method can be used to download an existing policy as a template for a new policy or you can make local modifications to a downloaded policy to override its function as the policy source defines it.</p> <pre><code>drutiny policy:download Test:Pass\n</code></pre>"},{"location":"Develop/Policy/GettingStarted/#naming-a-policy","title":"Naming a policy","text":"<p>If you want to create a new policy, be sure to change the <code>name</code> attribute in the .policy.yml file so Drutiny registers it as a new policy.</p> <pre><code>name: MyNewPolicy\n</code></pre>"},{"location":"Develop/Policy/GettingStarted/#updating-policy-registry","title":"Updating policy registry","text":"<p>Once the name has been changed, you'll need to run <code>policy:update</code> for Drutiny to rebuild the policy register and inherit the local filesystem changes. Drutiny should then find your new policy:</p> <pre><code>drutiny policy:update -s localfs\n</code></pre>"},{"location":"Develop/Policy/GettingStarted/#policy-structure","title":"Policy structure","text":"<p>A policy has a number of properties that can be defined to inform Drutiny how to audit for the policy and what content to show based on the outcome.</p> <p>Policies have mandatory (required) fields and optional fields. If a mandatory field is missing or if a field's value is of the wrong format or value, a validation exception will be thrown and the drutiny command will error.</p>"},{"location":"Develop/Policy/GettingStarted/#title-required","title":"title (required)","text":"<p>The human readable name and title of a given policy. The title should accurately indicate what the audit is for in as few words as possible. An expanded context can be given in the description field.</p> <pre><code>title: Shield module is enabled\n</code></pre>"},{"location":"Develop/Policy/GettingStarted/#name-required","title":"name (required)","text":"<p>The machine readable name of the policy. This is used to call the policy in <code>policy:audit</code> and to list in profiles. The naming convention is to use camel case and to delineate namespaces with colons.</p> <pre><code>name: Drupal:ShieldEnabled\n</code></pre>"},{"location":"Develop/Policy/GettingStarted/#class-required","title":"class (required)","text":"<p>The audit class used to assess the policy. The entire namespace should be given including a leading forward slash. If this class does not exist, Drutiny will fail when attempting to use this policy.</p> <pre><code>class: \\Drutiny\\Audit\\Drupal\\ModuleEnabled\n</code></pre>"},{"location":"Develop/Policy/GettingStarted/#type-default-audit","title":"type (default: audit)","text":"<p>Policies can be of two types: audit (the default) or data.</p> <p>Audit types evaluate the target for a pass/fail result. Data types simply collect and display the data.</p> <p>This property helps define how to best display the policy in an HTML report.</p> <pre><code>type: data\n</code></pre> <p>If the type is set to <code>data</code>then the audit cannot return a pass or fail outcome. However, an <code>audit</code> type policy will allow the audit to return <code>Drutiny\\Audit\\AuditInterface::NOTICE</code> and effectively function like a data policy type. This might be a preferred approach if the audit should return pass or fail in some scenarios.</p>"},{"location":"Develop/Policy/GettingStarted/#parameters","title":"parameters","text":"<p>Parameters allow a policy to define values for variables used by the Audit. An audit typically defines parameters as \"arguments\" and the policy sets these by declaring them as parameters under this declaration.</p> <p>The available parameters vary by audit which is depended by the <code>class</code> declaration. Use the <code>audit:info</code> command to learn more about the available arguments to configure the audit class with.</p> <p>Parameters are statically set and are typically used for configuring the audit specifically for how the policy wished to evaluate the target. If the parameters need to be dynamically set, then use <code>build_parameters</code>.</p> <pre><code>parameters:\n  module: dblog\n  status: Enabled\n</code></pre>"},{"location":"Develop/Policy/GettingStarted/#parametersvariables","title":"parameters.variables","text":"<p>For audit classes that extend <code>Drutiny\\Audit\\AbstractAnalysis</code>, you can provide a <code>variables</code> key under the <code>parameters</code> declaration that will be evaluated after the audit to help process audit data into formats that are easier to render policy messaging. <code>variables</code> are sequentially rendered using Twig syntax and preceeding variables can be used in proceeding variable renders.</p> <p>\u26a0\ufe0f Symfony ExpressionLanguage is no longer supported.</p>"},{"location":"Develop/Policy/GettingStarted/#example","title":"Example","text":"<pre><code>parameters:\n  variables:\n      core_needs_update: 'not ((core.releases|first).version = core.version)'\n</code></pre>"},{"location":"Develop/Policy/GettingStarted/#parametersfailif","title":"parameters.failIf","text":"<p>For audit classes that extend <code>Drutiny\\Audit\\AbstractAnalysis</code>, you can provide a <code>failIf</code> key under the <code>parameters</code> declaration that when evaluated will fail the audit if the expression returns true.  <code>failIf</code> uses Twig syntax.</p> <pre><code>parameters:\n  # Fail the policy if any alerts are detected.\n  failIf: alerts|length &gt; 0\n</code></pre> <p>\ud83d\udca1 Note: The <code>failIf</code> directive and the <code>expression</code> directive are mutually exclusive with <code>failIf</code> taking precedence. If the <code>failIf</code> parameter is declared in the policy, then the <code>expression</code> parameter will not be acted on.</p>"},{"location":"Develop/Policy/GettingStarted/#parameterswarningif","title":"parameters.warningIf","text":"<p>For audit classes that extend <code>Drutiny\\Audit\\AbstractAnalysis</code>, you can provide a <code>warningIf</code> key under the <code>parameters</code> declaration that when evaluated will add a warning to the audit outcome if the expression returns true. </p> <p>When a warning is added to an outcome, the <code>warning</code> messaging from the policy is added to policy response messaging.</p> <p>\u26a0\ufe0f This only applies to audit outcomes that fail or pass. Error and not applicable outcome states do not support warnings.</p> <p><code>warningIf</code> uses Twig syntax.</p> <pre><code>parameters:\n  # Raise a warning if results were successfully obtained, but errors were too.\n  warningIf: response.errors|length &gt; 0\n  failIf: response.results|length == 0\n</code></pre> <p>In the example above, irrespective of whether the policy passes or fails a warning can be raised if errors were found while obtaining the results.</p>"},{"location":"Develop/Policy/GettingStarted/#parametersomitif","title":"parameters.omitIf","text":"<p>For audit classes that extend <code>Drutiny\\Audit\\AbstractAnalysis</code>, you can provide an <code>omitIf</code> key under the <code>parameters</code> declaration that when evaluated to true, will return the policy prematurely with an \"Irrelevant\" state which will omit the policy result from a report.</p> <p>\u26a0\ufe0f omitIf is evaluated before variables in parameters.variables are evaluated so you cannot use those variables in your omitIf evaluation.</p> <pre><code>parameters:\n  # Omit if the \"response\" variable given by the audit class did not get defined.\n  # E.g. a condition was not met to produce this variable in the audit.\n  omitIf: response is undefined\n</code></pre>"},{"location":"Develop/Policy/GettingStarted/#parametersexpression","title":"parameters.expression","text":"<p>For audit classes that extend <code>Drutiny\\Audit\\AbstractAnalysis</code>, you can provide a <code>expression</code> key under the <code>parameters</code> declaration that when evaluated should return the audit outcome.</p> <p>This can be used instead of <code>failIf</code> when determining the audit outcome is more complicated than satisfying a single condition as a failure.</p> <p>The expression should return a predefined variable that represents the outcome.</p>"},{"location":"Develop/Policy/GettingStarted/#return-types","title":"Return types","text":"Variable Value Description <code>SUCCESS</code> true The policy successfully passed the audit. <code>PASS</code> 1 The same outcome as <code>SUCCESS</code> <code>FAIL</code> false The same outcome as <code>FAILURE</code> <code>FAILURE</code> 0 The policy failed to pass the audit. <code>NOTICE</code> 2 An audit returned non-assertive information. <code>WARNING</code> 4 An audit returned success with a warning. <code>WARNING_FAIL</code> 8 An audit returned failure with a warning. <code>ERROR</code> 16 An audit did not complete and returned an error. <code>NOT_APPLICABLE</code> -1 An audit was not applicable to the target. <code>IRRELEVANT</code> -2 An audit that is irrelevant to the assessment and should be omitted."},{"location":"Develop/Policy/GettingStarted/#example_1","title":"Example","text":"<pre><code>parameters:\n  expression: |\n    response.results is defined \n    ? ( response.results|length &gt; 0 ? SUCCESS : FAILURE ) \n    : IRRELEVANT\n</code></pre> <p>In the above example, we use shorthand twig syntax (<code>condition ? thisIfTrue : elseThis</code>) twice to determine  one of three outcomes (<code>SUCCESS</code>, <code>FAILURE</code> or <code>IRRELEVANT</code>).</p> <p>\ud83d\udca1 Note: You can use the <code>parameters.not_applicable</code> expression to predetermine if results make the policy not applicable. This maybe preferable in combination with the <code>failIf</code> expression.</p>"},{"location":"Develop/Policy/GettingStarted/#parametersnot_applicable","title":"parameters.not_applicable","text":"<p>For audit classes that extend <code>Drutiny\\Audit\\AbstractAnalysis</code>, you can provide a <code>not_applicable</code> key under the <code>parameters</code> declaration that when evaluated as true should return the audit outcome as not applicable.</p> <pre><code>parameters:\n  not_applicable: error.message is defined and \"incompatible\" in error.message\n</code></pre> <p>In the example above, if a output token called <code>error</code> contains a property called <code>message</code> and that message contains the word \"incompatible\", then the policy outcome will become not applicable.</p> <p>\u26a0\ufe0f This directive is evaluated before <code>expression</code>, <code>failIf</code> and <code>warningIf</code> expressions. If <code>not_applicable</code> is satisfied (evaluates to <code>true</code>), this these other directives will not be evaluated.</p>"},{"location":"Develop/Policy/GettingStarted/#parametersseveritycriticalif","title":"parameters.severityCriticalIf","text":"<p>For audit classes that extend <code>Drutiny\\Audit\\AbstractAnalysis</code>, you can provide a <code>severityCriticalIf</code> parameter  that when evaluated as true will increase the policy severity to critical.</p> <pre><code>severity: 'high'\nparameters:\n  failIf: errors|length &gt; 5\n  severityCriticalIf: errors|length &gt; 30\n</code></pre> <p>In the example above, the policy has a severity level of \"high\" and will fail when the error count goes above 5. When the error count goes above 30, then the severity will go from \"high\" to \"critical\".</p> <p>\ud83d\udca1 Note: <code>severityCriticalIf</code> can only raise the severity and not decrease it. Policies should be written with the lowest severity statically defined and then use <code>severityCriticalIf</code> to conditionally raise the severity to critical.</p>"},{"location":"Develop/Policy/GettingStarted/#parametersseverityhighif","title":"parameters.severityHighIf","text":"<p>For audit classes that extend <code>Drutiny\\Audit\\AbstractAnalysis</code>, you can provide a <code>severityHighIf</code> parameter  that when evaluated as true will increase the policy severity to high.</p> <pre><code>severity: 'normal'\nparameters:\n  failIf: errors|length &gt; 5\n  severityHighIf: errors|length &gt; 10\n  severityCriticalIf: errors|length &gt; 30\n</code></pre> <p>In the example above, the policy has a severity level of \"normal\" and will fail when the error count goes above 5. When the error count goes above 10, then the severity will go from \"normal\" to \"high\". When the error count goes above 30, then the severity will go from \"high\" to \"critical\".</p> <p>\ud83d\udca1 Note: <code>severityHighIf</code> can only raise the severity and not decrease it. Policies should be written with the lowest severity statically defined and then use <code>severityHighIf</code> to conditionally raise the severity to high.</p>"},{"location":"Develop/Policy/GettingStarted/#parametersseveritynormalif","title":"parameters.severityNormalIf","text":"<p>For audit classes that extend <code>Drutiny\\Audit\\AbstractAnalysis</code>, you can provide a <code>severityNormalIf</code> parameter  that when evaluated as true will increase the policy severity to normal.</p> <pre><code>severity: 'low'\nparameters:\n  failIf: errors|length &gt; 1\n  severityNormalIf: errors|length &gt; 5\n  severityHighIf: errors|length &gt; 10\n  severityCriticalIf: errors|length &gt; 30\n</code></pre> <p>In the example above, the policy has a severity level of \"low\" and will fail when the error count goes above 1. When the error count goes above 5, then the severity will go from \"low\" to \"normal\". When the error count goes above 10, then the severity will go from \"normal\" to \"high\". When the error count goes above 30, then the  severity will go from \"high\" to \"critical\".</p> <p>\ud83d\udca1 Note: <code>severityNormalIf</code> can only raise the severity and not decrease it. Policies should be written with the lowest severity statically defined and then use <code>severityNormalIf</code> to conditionally raise the severity to normal.</p>"},{"location":"Develop/Policy/GettingStarted/#build_parameters","title":"build_parameters","text":"<p>If you need to dynamically produce your parameters inside the policy you can do so with <code>build_parameters</code>. This is often required when a policy must provide arguments to its audit class but needs an opportunity to do so before policy <code>variables</code> are executed (exclusive to <code>Drutiny\\Audit\\AbstractAnalysis</code>). <code>build_parameters</code> consists of key value pairs where the values are executed through the twig engine and the result is set as a parameter for the provided key.</p> <pre><code>build_parameters:\n  domain: 'parse_url(target.url, 1)'\n</code></pre> <p>In the example above, the <code>domain</code> is dynamically provided based on the url of the target object. Since that data comes from the target, it cannot be statically defined in the <code>parameters</code> section of the policy. So we use the <code>build_parameters</code> feature to set parameters based on their evaluated value rather than their static value.</p>"},{"location":"Develop/Policy/GettingStarted/#depends","title":"depends","text":"<p>The depends directive allows policies to only apply if one or more conditions are meet such as an enabled module or the value of a target environmental variable (like OS).</p> <p>Dependencies can be evaluated in Twig syntax.</p> <p>\u26a0\ufe0f ExpressionLanguage is no longer supported.</p> <pre><code>depends:\n  - expression: Policy.succeeds('fs:largeFiles')'\n    on_fail: 'error'\n  - expression: Drupal.moduleIsEnabled('syslog') &amp;&amp; Drupal.moduleVersionSatisfies('purge', '^4.0')\n</code></pre> <p>Each depends item must have an associated <code>expression</code> key with the expression to evaluate. Optionally, an <code>on_fail</code> property can be added to indicate the failure behaviour:</p>"},{"location":"Develop/Policy/GettingStarted/#on-fail","title":"On fail","text":"Value Behaviour <code>omit</code> Omit policy from report <code>fail</code> Fail policy in report <code>error</code> Report policy as error <code>report_only</code> Report as not applicable"},{"location":"Develop/Policy/GettingStarted/#description-required","title":"description (required)","text":"<p>A human readable description of the policy. The description should be informative enough for a human to read the description and be able to interpret the audit findings.</p> <p>This field is interpreted as Markdown You can use Twig templating to render dynamic content.</p> <pre><code>description: |\n  Using the pipe (|) symbol in yaml,\n  I'm able to provide my description\n  across multiple lines.\n</code></pre>"},{"location":"Develop/Policy/GettingStarted/#success-required","title":"success (required)","text":"<p>The success message to provide if the audit returns successfully.</p> <p>This field is interpreted as Markdown You can use Twig templating to render dynamic content.</p> <p>Available variables are those passed in as parameters or set as tokens by the audit class.</p> <pre><code>success: The module {{module_name}} is enabled.\n</code></pre>"},{"location":"Develop/Policy/GettingStarted/#failure-required","title":"failure (required)","text":"<p>If the audit fails or is unable to complete due to an error, this message will</p> <p>This field is interpreted as Markdown You can use Twig templating to render dynamic content.</p> <p>Available variables are those passed in as parameters or set as tokens by the audit class.</p> <pre><code>failure: {{module_name}} is not enabled.\n</code></pre>"},{"location":"Develop/Policy/GettingStarted/#tags","title":"tags","text":"<p>The tags key is simply a mechanism to allow policies to be grouped together. For example \"Drupal 9\" or \"Performance\".</p> <pre><code>tags:\n  - Drupal 9\n  - Performance\n</code></pre>"},{"location":"Develop/Policy/GettingStarted/#severity","title":"severity","text":"<p>Not all policies are of equal importance. Severity allows you to specify how critical a failure or warning is. Possible values in order of importance:</p> <ul> <li>none (only option for <code>data</code> type policies)</li> <li>low</li> <li>medium (default)</li> <li>high</li> <li>critical</li> </ul> <pre><code>severity: 'high'\n</code></pre>"},{"location":"Develop/Policy/GettingStarted/#audit_build_info","title":"audit_build_info","text":"<p>audit_build_info is metadata attached to a policy indicating the audit classes the policy was built with and their versions. This is used to determine if the  policy can be run within the current runtime. This is useful if the runtime where you're running the policy is different the runtime you create the policy in or if your version of drutiny changes overtime.</p> <pre><code>audit_build_info:\n    - 'Drutiny\\Audit\\AbstractAnalysis:1.0'\n</code></pre> <p>The above example shows that the policy was built with the audit class <code>Drutiny\\Audit\\AbstractAnalysis</code> when it was at version 1.0. Future versions of this class will be able to evaluate this policy by its version to determine if it can still run the policy.</p> <p>For more information see Audit Versions.</p>"},{"location":"Develop/Policy/GettingStarted/#chart","title":"chart","text":"<p>Charts in Drutiny are an HTML format feature that allows rendered tabular data in a policy to be visualized in a chart inside of the HTML generated report.</p> <p>Under the hood, Drutiny uses chart.js to render charts.</p> <p>A chart is defined inside of a Policy as metadata and rendered inside of either the success, failure, warning or remediation messages also provided by the policy.</p> <pre><code>chart:\n  requests:\n    type: doughnut\n    labels: tr td:first-child\n    hide-table: false\n    title: Request Distribution by Domain\n    height: 300\n    width: 400\n    legend: left\n    colors:\n      - rgba(46, 204, 113,1.0)\n      - rgba(192, 57, 43,1.0)\n      - rgba(230, 126, 34,1.0)\n      - rgba(241, 196, 15,1.0)\n      - rgba(52, 73, 94,1.0)\n    series:\n      - tr td:nth-child(4)\nsuccess: |\n  Here is a doughnut chart:\n  {{_chart.requests|chart}}\n</code></pre>"},{"location":"Develop/Policy/GettingStarted/#configuration","title":"Configuration","text":"<p>Any given policy may have a <code>chart</code> property defined in its <code>.policy.yml</code> file. The <code>chart</code> property contains a arbitrarily keyed set of chart definitions.</p> <pre><code>chart:\n  my_chart_1:\n    # ....\n  my_chart_2:\n    # ....\n</code></pre> <p>Charts use tabular data from the first sibling table in the DOM.</p>"},{"location":"Develop/Policy/GettingStarted/#chart-properties","title":"Chart Properties","text":"<p><code>labels</code> and <code>series</code> use css selectors powered by jQuery to obtain the data to display in the chart.</p> Property Description <code>type</code> The type of chart to render. Recommend <code>bar</code>, <code>pie</code> or <code>doughnut</code>. <code>labels</code> A css selector that returns an array of HTML elements whose text will become labels in a pie chart or x-axis in a bar graph. <code>hide-table</code> A boolean to determine if the table used to read the tabular data should be hidden. Defaults to false. <code>title</code> The title of the graph <code>series</code> An array of css selectors that return the HTML elements whose text will become chart data. <code>height</code> The height of the graph area set as a CSS style on the <code>&lt;canvas&gt;</code> element. <code>width</code> The width of the graph area set as a CSS style on the <code>&lt;canvas&gt;</code> element. <code>x-axis</code> The label for the x-axis. <code>y-axis</code> The label for the y-axis. <code>legend</code> The position of the legend. Options are: top, bottom, left, right or none (to remove legend). <code>colors</code> An array of colors expressed using RGB syntax. E.g. <code>rgba(52, 73, 94,1.0)</code>."},{"location":"Develop/Policy/GettingStarted/#rendering-a-chart","title":"Rendering a Chart","text":"<p>Rendered charts are available as a special <code>_chart</code> token to be used in success, failure, warning or remediation messages provided by the policy.</p> <pre><code>success: |\n  Here is the chart:\n  {{_chart.my_chart_1|chart}}\n</code></pre>"},{"location":"Develop/Policy/GettingStarted/#using-tokens-in-message-renders","title":"Using Tokens in message renders.","text":"<p>Tokens are variables you can use in the render of policy messaging. This includes success, failure, warning and description fields defined in a policy.</p>"},{"location":"Develop/Policy/GettingStarted/#available-tokens","title":"Available Tokens","text":"<p>Use the <code>policy:info</code> command to identify which tokens are available in a policy for use in the render.</p> <pre><code>$ drutiny policy:info fs:largeFiles\n</code></pre> <p>You can see in the above example output, that <code>fs:largeFiles</code> contains three  tokens: <code>_max_size</code>, <code>issues</code> and <code>plural</code>. These tokens are available to use as  template variables when writting messaging for a policy:</p> <pre><code>failure: |\n  Large public file{{plural}} found over {{max_size}}\n  {% for issue in issues %}\n     - {{issue}}\n  {% endfor %}\n</code></pre> <p>These variables are rendered using Twig templating.  The messages are also parsed by a markdown parser when rendering out to HTML.</p>"},{"location":"Develop/Policy/Pipelines/","title":"Pipelines","text":"<p>Pipelines allows you to gather data across multiple audit classes in a single policy. While the policy structure and format remains the same, pipelines can contain a complex  amount of configuration in the <code>parameters</code> section.</p> <p>Pipelines are achieved by using the <code>Drutiny\\Audit\\AuditAnalysisPipeline</code> class.</p>"},{"location":"Develop/Policy/Pipelines/#pipeline-example","title":"Pipeline example","text":"<pre><code>title: Domain verficiation errors\nclass: Drutiny\\Audit\\AuditAnalysisPipeline\ndescription: When your domain is unverified, our system will error.\nbuild_parameters:\n    verification_code: target.verification_code\nparameters:\n    pipeline:\n        - name: logs\n          class: Drutiny\\SumoLogic\\Audit\\QueryAnalysis\n          parameters:\n            ^query: _sourceCategory=syslog \"[ERROR] domain {target.domain} is unverified.\"\n          continueIf: logs.records|length &gt; 0\n        - name: dns\n          class: Drutiny\\Audit\\DNS\\DnsAnalysis\n          parameters:\n            type: TXT\n            $zone: target.domain\n            variables:\n                verified: dns !== false and verification_code in dns.txt\n    failIf: logs.records|length &gt; 0\nsuccess: No errors found.\nfailure: |\n    Found {{ logs.records|length }} errors in the log file.\n\n    {% if not dns.verified %}\n    Your DNS is not verified. It requires the following DNS record:\n\n    ```\n    {{ target.domain }} 3600 IN TXT {{ verification_code }}\n    ```\n\n    {% endif %}\n</code></pre> <p>Lets walk through the example above:</p> <ol> <li>The policy defines <code>build_parameters</code> with a single parameters called     <code>verification_code</code>. This is just to make it easier to reference later.</li> <li>There is a parameter called <code>pipeline</code> which contains an array of sequential    audits to gather data from.</li> <li>Each stage in the pipeline contains three mandatory keys: name, class and     parameters.</li> <li>The <code>name</code> key specifies the name of the pipeline and is also a prefix for       referencing variables/tokens built in the audit.</li> <li>The <code>class</code> key specifies which class to use in the stage.</li> <li>The <code>parameters</code> key defines the parameters to pass into the class.</li> <li>There is an optional key called <code>continueIf</code> which allows you to stop the      pipeline at a given point if the evaluated expression returns <code>false</code>.</li> <li>By using the caret (<code>^</code>) infront of a parameter name, the value will have    have token replacement processing conducted over it. This will translate the     value <code>{target.domain}</code> into the actual domain of the target.    See Dynamic parameters.</li> <li>By using the dollars sign (<code>$</code>) infront of a parameter name, the value will    by evaluated by twig. This allows the <code>$zone</code> parameter value to be the actual     domain of the target. See Dynamic parameters.</li> <li>The <code>failIf</code> parameter refers to data gathered by the <code>logs</code> stage of the     pipeline. The <code>records</code> variable from that part of the pipeline is     accessible via <code>logs.records</code>.</li> <li>The <code>failure</code> message uses the pipeline names <code>logs</code> and <code>dns</code> to access    tokens gathered by those respective audits in the pipeline.</li> </ol> <p>Pipelines do not have <code>build_parameters</code>. You can use the policy's <code>build_parameters</code> to evaluate parameters before the pipeline starts. You can also use the <code>variables</code> parameter within each pipeline to process outputs inbetween pipeline stages ready for the next stage. Finally parameters can use process markers on their keys to allow for dynamic processing of parameters.  See Dynamic parameters.</p>"},{"location":"Develop/Policy/TwigExtensions/","title":"Twig Extensions","text":"<p>Drutiny uses the Twig templating engine to:</p> <ul> <li>Template profile reports into Markdown and HTML formats</li> <li>Template policy success, failure, warning, remediation and description messages.</li> <li>Evaluate dynamic parameters including <code>build_parameters</code>,   <code>expression</code>, <code>failIf</code> and more.</li> </ul> <p>Drutiny uses Twig 3 and you can refer to Twig's documentation  and reference manual for how to work with Twig templates and programming syntax.</p> <p>Drutiny extends Twig with additional language features to help support the way Drutiny uses Twig.</p>"},{"location":"Develop/Policy/TwigExtensions/#default-extensions","title":"Default Extensions","text":"<p>By default, Drutiny loads three extensions from Twig:</p> <ul> <li><code>Twig\\Extension\\DebugExtension</code></li> <li><code>Twig\\Extension\\StringLoaderExtension</code></li> <li><code>Twig\\Extra\\String\\StringExtension</code></li> </ul>"},{"location":"Develop/Policy/TwigExtensions/#line-breaks","title":"Line breaks","text":"<p>One point of differences between Twig and Drutiny's Twig is how line breaks are handled in policy expressions. Typically Twig programing takes place on a single line but in Drutiny you can break that up over multiple lines to improve readibility of longer fragments of Twig.</p> <pre><code>parameters:\n    failIf: |\n        values \n        | array_filter(\n            value =&gt; value.status == 200\n        )\n        | length\n</code></pre>"},{"location":"Develop/Policy/TwigExtensions/#expression-reference","title":"Expression reference","text":"<p>Drutiny contains a command called <code>expression:reference</code> which can be called to get a list  of alias twig expressions that can be used in addition to this documentation.</p> <pre><code>drutiny expression:reference\n</code></pre>"},{"location":"Develop/Policy/TwigExtensions/#filters","title":"Filters","text":"<p>Filters are functions that can have data \"piped\" into them and must always proceed a <code>|</code> in twig syntax.</p> <pre><code>input_data | filter(...args)\n</code></pre>"},{"location":"Develop/Policy/TwigExtensions/#array_merge-deprecated","title":"array_merge (deprecated)","text":"<p>array_merge is identical to Twig's merge filter. It is deprecated, use <code>merge</code> instead.</p> <pre><code>parameters:\n    variables:\n        # Creates [1,2,'a', 'b']\n        values: '[1,2]|array_merge(['a', 'b'])'\n</code></pre>"},{"location":"Develop/Policy/TwigExtensions/#sum","title":"sum","text":"<p>The <code>sum</code> filter allows you to sum an array of values like PHP's array_sum.</p> <pre><code>parameters:\n    variables:\n        # 10\n        value: '[1, 2, 3, 4] | sum'\n</code></pre>"},{"location":"Develop/Policy/TwigExtensions/#unique","title":"unique","text":"<p>The <code>unique</code> filter will filter down an array of values to unique values. Like PHP's array_unique.</p> <pre><code>parameters:\n    variables:\n        # [1, 2, 3, 4]\n        value: '[1, 2, 1, 3, 2, 4, 3] | unique'\n</code></pre>"},{"location":"Develop/Policy/TwigExtensions/#values","title":"values","text":"<p>The <code>values</code> filter turns the keys in an array into a numeric sequence like PHP's array_values.</p> <pre><code>parameters:\n    variables:\n        # ['bar']\n        value: '{foo: \"bar\"} | values'\n</code></pre>"},{"location":"Develop/Policy/TwigExtensions/#chart","title":"chart","text":"<p>The <code>chart</code> filter converts a policy chart object into an HTML snippet ready for chart.js rendering with Drutiny HTML profile templates.</p> <pre><code>chart:\n    my_line_graph:\n        # ... See policy charts.\nsuccess: |\n    {{ chart.my_line_graph|chart }}\n</code></pre>"},{"location":"Develop/Policy/TwigExtensions/#extract","title":"extract","text":"<p>The <code>extract</code> filter allows you to extract values from strings using regular expressions. The first argument is the regular expression to match and the second argument is the  index of the match to return where zero returns the entire match and subsequent numbers represent any bracket matches within the string.</p> <pre><code>parameters:\n    variables:\n        output: \"The quick brown fox jumps over the lazy dog\"\n        # Returns \"brown\".\n        color: output | extract('/quick (a-z+) fox/', 1)\n</code></pre>"},{"location":"Develop/Policy/TwigExtensions/#format_bytes","title":"format_bytes","text":"<p>The <code>format_bytes</code> filter will format bytes into bytes (B), kilobytes (KB), megabytes (MB), gigabytes (GB) or terabytes (TB) depending on the size of bytes passed to the filter.</p> <pre><code>parameters:\n    variables:\n        bytes: 1258291\n# 1.2MB\nsuccess: There are {{ bytes | format_bytes }} of data.\n</code></pre>"},{"location":"Develop/Policy/TwigExtensions/#json_decode","title":"json_decode","text":"<p>The <code>json_decode</code> filter functions like json_decode in PHP. This is largely an  internal function used to extract variables from twig strings.</p>"},{"location":"Develop/Policy/TwigExtensions/#heading","title":"heading","text":"<p>The <code>heading</code> filter decorates headings in profile templates so that HTML navigation can use the headings for menus and tables of contents. The heading size can be passed as the first argument.</p> <pre><code>format:\n    html:\n        content: |\n            {% block test_pass %}\n              {% set response = assessment.getPolicyResult('Test:Pass') %}\n              {{ response.policy.title | heading(3) }}\n              {% with response.tokens %}\n                {{ include(template_from_string(response.policy.description)) | markdown_to_html }}\n                {{ include(template_from_string(response.policy.success)) | markdown_to_html }}\n              {% endwith %}\n            {% endblock %}\n</code></pre>"},{"location":"Develop/Policy/TwigExtensions/#escape_md","title":"escape_md","text":"<p>The escape_md filter allow you to escape text that may otherwise be interpreted by markdown later on.</p> <pre><code>parameters:\n    variables:\n        command: cat apache-access.log | grep ' 200 '\nfailure: |\n    We didn't find any HTTP 200 status response using this command:\n\n    Command | Result\n    ------- | ------\n    {{ command|escape_md }} | {{ result }}\n</code></pre>"},{"location":"Develop/Policy/TwigExtensions/#yaml_dump","title":"yaml_dump","text":"<p>The <code>yaml_dump</code> filter is a debug filter that can be used to dump contents into yaml format for viewing. And is a wrapper for Symfony's Yaml::dump utility.</p> <pre><code>parameters:\n    variables:\n        '!configuration':\n            bad: 'config'\n            int: '1',\n            bool: 0\n    failIf: configuration.bool is same as(false)\nfailure: |\n    Your configuration is incorrect:\n    ```yaml\n    {{ configuration|yaml_dump }}\n    ```\n</code></pre>"},{"location":"Develop/Policy/TwigExtensions/#functions","title":"Functions","text":"<p>Functions in twig cannot be \"piped\" into. Data can only be passed in via arguments.</p> <pre><code>{{ function(..args) }}\n</code></pre>"},{"location":"Develop/Policy/TwigExtensions/#chart_and_table","title":"chart_and_table","text":"<p>The <code>chart_and_table</code> function renders both a table and chart in a policy messaging field (success, failure, warning, remediation). The chart is further preconfigured to dynamically set series, labels and x-axis based on the columns and rows of the table.</p> <p>Note: Pie charts are not tested with this function.</p> <ul> <li>The first column will be the x-axis.</li> <li>Subsequent columns will be series in the line or bar graph.</li> </ul> <p>The <code>chart_and_table</code> function takes three arguments: * headers - the headers to use for the table, * rows - and array of rows for the table, * chart object - the chart object pre-configured from the policy definition.</p> <pre><code>chart:\n    my_line_graph:\n        # ...\nbuild_parameters:\n    '!headers':\n        - Sequence\n        - Car\n        - Bike\nparameters:\n    variables:\n        '!rows':\n            - [1, 20, 30]\n            - [2, 25, 40]\n            - [3, 30, 50]\n            - [4, 35, 60]\nsuccess: |\n    ## Speed after X seconds\n    {{ chart_and_table(headers, rows, chart.my_line_graph) }}\n</code></pre>"},{"location":"Develop/Policy/TwigExtensions/#combine","title":"combine","text":"<p>The <code>combine</code> function works like PHP's array_combine.</p> <pre><code>parameters:\n    variables:\n        # {foo: 'bar'}\n        data: array_combine(['foo'], ['bar'])\n</code></pre>"},{"location":"Develop/Policy/TwigExtensions/#explode-deprecated","title":"explode (deprecated)","text":"<p>The <code>explode</code> function works like PHP's explode function. Twig has its own filter called <code>split</code> which should be used instead.</p> <pre><code>parameters:\n    variables:\n        data: '1,2,3,4,5,6'\n        values: explode(',', data)\n        # use split instead\n        values: data | split(',')\n</code></pre>"},{"location":"Develop/Policy/TwigExtensions/#is_target","title":"is_target","text":"<p>The is_target function returns a boolean depending on if the passed variable is a target or of the right type of target.</p> <p>An expression:reference alias for this exists called <code>Target.typeOf</code> which can be used to ensure a policy can only be used by a specific type of target.</p> <pre><code>name: Drupal:SyslogModule:enabled\nclass: Drutiny\\Audit\\Drupal\\ModuleAnalysis\ndepends:\n    # Ensure the target type is or extends the drush target type.\n    - expression: Target.typeOf('drush')\n</code></pre>"},{"location":"Develop/Policy/TwigExtensions/#parse_url","title":"parse_url","text":"<p>The <code>parse_url</code> function works like PHP's parse_url function. Potential keys within this array are:</p> <ul> <li>scheme - e.g. http</li> <li>host</li> <li>port</li> <li>user</li> <li>pass</li> <li>path</li> <li>query - after the question mark ?</li> <li>fragment - after the hashmark #</li> </ul> <pre><code>parameters:\n    url: https://www.google.com/search?q=drutiny\n    variables:\n        link: parse_url(url)\n        host: link.host\n</code></pre>"},{"location":"Develop/Policy/TwigExtensions/#pluralize","title":"pluralize","text":"<p>The <code>pluralize</code> function helps chose a singular or pluralized word based on a given number.</p> <pre><code>You have a {{ pluralize(sheep_count, 'single', 'flock of') }} sheep in your paddock.\n</code></pre> <pre><code>Found {{ file_count }} {{ pluralize(file_count, 'file', 'files') }}.\n</code></pre>"},{"location":"Develop/Policy/TwigExtensions/#policy_result","title":"policy_result","text":"<p>The <code>policy_result</code> function renders a policy audit response. This is useful in  profile templating:</p> <pre><code>format:\n    html:\n        content: |\n            {{ policy_result(assessment.getPolicyResult('Test:Pass'), assessment }}\n</code></pre> <p>policy_result requires two arguments: - The policy audit response to render. - The assessment object which is available in profile templates.</p>"},{"location":"Develop/Policy/TwigExtensions/#semver_satisfies","title":"semver_satisfies","text":"<p>The <code>semver_satisfies</code> function allows you to test if a semantic version works with a given versioning constraint as described by Composer.</p> <p>An expression:reference alias for this function exists called <code>SemVer.satisfies</code>.</p> <pre><code>parameters:\n    failIf: SemVer.satisfies(module.version, '&lt;3.4')\n</code></pre>"},{"location":"Develop/Policy/TwigExtensions/#tests","title":"Tests","text":"<p>Tests return boolean based on there assessment.</p>"},{"location":"Develop/Policy/TwigExtensions/#numeric","title":"numeric","text":"<p>Returns true if the value is numeric. Like PHP's is_numeric function.</p> <pre><code>parameters:\n    variables:\n        # String '1'\n        number: '1'\n    # Is string but is numeric so fail condition not met.\n    failIf: number is not numeric\n</code></pre>"},{"location":"Develop/Policy/TwigExtensions/#keyed","title":"keyed","text":"<p>Returns true if the variable is an array and the first key is a string.</p> <p>Note: future versions of this will likely mimic PHP's array_is_list function.</p> <pre><code>parameters:\n    variables:\n        values: 'data is keyed ? (data|values) : data'\n</code></pre>"},{"location":"Develop/Profile/GettingStarted/","title":"Profiles","text":"<p>Profiles are a collection of policies that aim to audit a target against a specific context or purpose. Some examples of profile use cases are:</p> <ul> <li>Production-ready Drupal 8 site</li> <li>Organizational policy compliance</li> <li>Security or performance audit</li> </ul> <p>Profiles allow you to run a defined set of polices into a report.</p> <pre><code>./vendor/bin/drutiny profile:run &lt;profile_name&gt; &lt;target&gt;\n</code></pre> <p>Reports can also be rendered into HTML or JSON and saved to file.</p> <pre><code>./vendor/bin/drutiny profile:run &lt;profile_name&gt; &lt;target&gt; --format=html -o &lt;filename&gt;\n</code></pre>"},{"location":"Develop/Profile/GettingStarted/#creating-a-profile","title":"Creating a Profile","text":"<p>Profiles are YAML files with a file extension of <code>.profile.yml</code>. These can be placed anywhere in the directory you run Drutiny from. It is recommended to store them in a directory called <code>Profile</code>.</p>"},{"location":"Develop/Profile/GettingStarted/#fields","title":"Fields","text":""},{"location":"Develop/Profile/GettingStarted/#title-required","title":"title (required)","text":"<p>The title field gives semantic meaning to the collection of policies.</p> <pre><code>title: My custom audit\n</code></pre>"},{"location":"Develop/Profile/GettingStarted/#description","title":"description","text":"<p>A description of the profiles purpose and why it might be used.</p> <pre><code>description: |\n  This profile is to be used to determine if your site is following\n  the best practices for security.\n</code></pre>"},{"location":"Develop/Profile/GettingStarted/#policies-required","title":"policies (required)","text":"<p>A list of policies that make up the profile.</p> <pre><code>policies:\n  Drupal-7:NoDuplicateModules: {}\n  Drupal-7:OverlayModuleDisabled: {}\n  Drupal-7:BlackListPermissions: {}\n  Drupal-7:PhpModuleDisabled: {}\n</code></pre> <p>Policy definitions can contain profile specific overrides for parameters passed to the policy as well as the severity of the policy in context to the profile.</p> <pre><code>policies:\n  Database:Size:\n    parameters:\n      max_size: 900\n    severity: critical\n</code></pre> <p>Note: This is a change from the 2.0.x profile format. Older profiles that provided default parameters will error.</p>"},{"location":"Develop/Profile/GettingStarted/#dependencies","title":"dependencies","text":"<p>A list of policies that are run to evaluate the target is appropriate for the given profile. All policies listed as a dependency must pass for the target to be considered valid for the profile.</p> <p>Dependency failures are reported to the Drutiny CLI. Dependencies are not reported in a successful profile audit.</p> <p>The dependency declaration follows the same schema as the <code>policies</code> declaration.</p> <pre><code>dependencies:\n  Database:Size:\n    parameters:\n      max_size: 900\n    severity: critical\n</code></pre>"},{"location":"Develop/Profile/GettingStarted/#include","title":"include","text":"<p>The include directive allows profiles to be build on top of collections or other profiles. Each include name should be the machine name of another available profile.</p> <pre><code>include:\n  - cloud\n  - d8\n</code></pre>"},{"location":"Develop/Profile/GettingStarted/#excluded_policies","title":"excluded_policies","text":"<p>This directive allows a profile to exclude policies that were implicitly included in an included profile defined in the <code>include</code> directive.</p> <pre><code>excluded_policies:\n  - Drupal-7:BlackListPermissions\n  - Drupal-7:CSSAggregation\n</code></pre>"},{"location":"Develop/Profile/GettingStarted/#format","title":"format","text":"<p>The <code>format</code> declaration allows a profile to specify options specific to the export format of the report (console, HTML or JSON). Based on the format, the options vary.</p> <p>Right now there are no specific options for <code>console</code> or <code>json</code> formats. Only HTML.</p> <pre><code>format:\n  html:\n    template: my-page\n    content:\n      - heading: My custom section\n        body: |\n          This is a multiline field that can contain mustache and markdown syntax.\n          There are also a variety of variables available to dynamically render\n          results.....\n</code></pre>"},{"location":"Develop/Profile/GettingStarted/#formathtmltemplate","title":"format.html.template","text":"<p>The template to use to theme an HTML report. Defaults to <code>page</code>. To add your own template you need to register a template directory in <code>drutiny.yml</code> and add a template twig file to that directory.</p> <p>drutiny.yml:</p> <pre><code>services:\n  myDrutinyTemplates:\n    class: Twig\\Loader\\FilesystemLoader\n      arguments:\n        - path/to/twig/template/dir\n      tags: [twig.loader]\n</code></pre> <p>path/to/twig/template/dir/my-page.html.twig</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;title&gt;{{ profile.title }} - {{ assessment.uri }}&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;{{ profile.title }}&lt;/h1&gt;\n  &lt;div&gt;\n    {{ profile.description | markdown_to_html }}\n  &lt;/div&gt;\n  {% include 'report/page/sections.html.twig' %}\n\n  &lt;footer&gt;\n    &lt;p&gt;&amp;copy; Drutiny {{ 'now' | date('Y') }} | {{ \"now\"|date(\"F jS, Y\") }}&lt;/p&gt;\n  &lt;/footer&gt;\n  {% include 'report/page/footer.html.twig' %}\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>myprofile.profile.yml:</p> <pre><code>format:\n  html:\n    template: my-page.html.twig\n</code></pre> <p>The configuration example above will register the <code>path/to/twig/template/dir</code> directory. When rendering an HTML report, Drutiny will look inside <code>path/to/twig/template/dir</code>, among other registered template directories, for a template called <code>my-page.html.twig</code>. Note that multiple template directories can be registered so your template should be uniquely named.</p>"},{"location":"Develop/Profile/GettingStarted/#formathtmlcontent","title":"format.html.content","text":"<p>Specify the content displayed in an HTML report and the order that it displays in. Drutiny uses Twig templating for content rendering and by default will load the contents of profile.html.twig.</p> <p>The Twig template is made up of <code>block</code> sections that Drutiny relies on to build out the page. If content is not inside a Twig block, then it will not be displayed.</p> <pre><code>format:\n  html:\n    content: |\n      {% block purpose %}\n        {{ 'Purpose' | heading }}\n\n        Piping a string through the `heading` twig filter will ensure the HTML\n        generated contains classes for better styling of report headings vs\n        policy headings.\n      {% endblock %}\n\n      This sentence will not be displayed because it is outside of a block.\n\n      {% block period %}\n        {{ 'Reporting period' | heading }}\n\n        Period | Date time\n        ------ | ---------\n        Start | {{ assessment.reportingPeriodStart.format('Y-m-d H:i:s e') }}\n        End | {{ assessment.reportingPeriodEnd.format('Y-m-d H:i:s e') }}\n      {% endblock %}\n</code></pre>"},{"location":"Develop/Profile/GettingStarted/#content-variables","title":"Content Variables","text":"<p>These are the variables available to the <code>format.html.content</code> template.</p>"},{"location":"Develop/Profile/GettingStarted/#assessment","title":"assessment","text":"<p>The assessment variable contains the results of each audited policy in the <code>results</code> property. Each result has properties to test if it was successful, a notice, error or warning.</p> <pre><code>    {# Iterate of each failed result and render its recommendation #}\n    {% for result in assessment.results|filter(r =&gt; r.isFailure) %}\n      {% with result.tokens %}\n        {{ include(template_from_string(result.policy.remediation)) | markdown_to_html }}\n      {% endwith %}\n    {% endfor %}\n</code></pre>"},{"location":"Develop/Profile/GettingStarted/#assessmentresults","title":"assessment.results","text":"<p>Each <code>result</code> from <code>assessment.results</code> is an instance of AuditResponse and has access to the <code>policy</code> properties via the <code>policy</code> property. This allows you to render <code>success</code>, <code>failure</code>, <code>warning</code> and <code>remediation</code> messages for a given result using the <code>template_from_string</code> function in twig.</p> <pre><code>{% with result.tokens %}\n  {{ include(template_from_string(result.policy.success)) | markdown_to_html }}\n{% endwith %}\n</code></pre> <p>The <code>with</code> twig tag allow the <code>result.tokens</code> array to be accessible as variables inside the policy template content. This is especially important if your policy content wishes to use token variables.</p>"},{"location":"Develop/Profile/GettingStarted/#assessmenturi","title":"assessment.uri","text":"<p>This is the URI a target was audited with and can be used as a reference for the target.</p>"},{"location":"Develop/Profile/GettingStarted/#profile","title":"profile","text":"<p>The <code>profile</code> variable is an instance of Profile and has access to the profile properties. Namely for content templating purposes, the profile is most valuable for its <code>title</code> and <code>description</code> attributes.</p>"},{"location":"Usage/Policy/","title":"Policy Usage","text":"<p>Policy objects define how an audit in Drutiny should assess a given target. Drutiny has a library of policies to choose from provided by a collection of pluggable sources.</p>"},{"location":"Usage/Policy/#discover","title":"Discover","text":"<p>To find what policies are available in your instance of Drutiny, us the <code>policy:list</code>command.</p> <pre><code>drutiny policy:list\n</code></pre> <p>This should provide you with a table of available policies including the policy title, name, source and profile utilisation.</p> <p>Drutiny defaults to english but will provides policies in other languages if your Policy sources support multilingual policies.</p> <pre><code># List policies written in Japanese.\ndrutiny policy:list --language=ja\n</code></pre>"},{"location":"Usage/Policy/#policy-information","title":"Policy information","text":"<p>The title and name of the policy should be indicative of what the policy audits for and assesses. To find out more information, use the <code>policy:info</code> command to see the description and parameters used in the audit.</p> <pre><code>drutiny policy:info &lt;policy:name&gt;\n</code></pre> <p>The output from this command should also give you an example of how to audit a target against this policy.</p>"},{"location":"Usage/Policy/#auditing-a-target-against-a-policy","title":"Auditing a target against a policy.","text":"<p>Using the <code>policy:audit</code> command you can assess a single policy against a single target.</p> <pre><code>drutiny policy:audit &lt;policy:name&gt; &lt;target&gt;\n</code></pre> <p>Use the name column from the <code>policy:list</code>command as the <code>&lt;policy:name&gt;</code> argument. The target argument should be an identifier from the <code>target:list &lt;source&gt;</code> command. See Target Usage for more information.</p>"},{"location":"Usage/Profile/","title":"Profile Usage","text":"<p>Profiles allow you to run a group of policies against a given target and format the results into a report.</p>"},{"location":"Usage/Profile/#discover","title":"Discover","text":"<p>The profiles available in Drutiny can be found using the <code>profile:list</code> command.</p> <pre><code>drutiny profile:list\n</code></pre> <p>This should provide you with a table of available profiles including the profile title, name, and source.</p>"},{"location":"Usage/Profile/#profile-information","title":"Profile information","text":"<p>Additonal information about a specific profile can be viewed using the <code>profile:info &lt;profile:name&gt;</code> command. Specifically, this command informs you of the policies in use by this profile.</p> <pre><code>drutiny profile:info &lt;profile:name&gt;\n</code></pre> <p>For more information on individual policies, use the <code>policy:info</code> command. See policy usage for more information.</p>"},{"location":"Usage/Profile/#auditing-a-target-againt-a-profile","title":"Auditing a target againt a profile","text":"<p>Using the <code>profile:run</code> command you can assess a target against the list of policies in the profile.</p> <pre><code>drutiny profile:run &lt;profile:name&gt; &lt;target&gt;\n</code></pre> <p>The target argument should be an identifier from the <code>target:list &lt;source&gt;</code> command. See Target Usage for more information.</p>"},{"location":"Usage/Profile/#formatting-profile-reports","title":"Formatting profile reports","text":"<p>Drutiny supports a number of formats. The default formats include terminal (default), json, csv, markdown and html. When using <code>profile:run</code>you can specify one or more formats to render the report out to. Use the <code>--format</code> or <code>-f</code> options to set a format.</p> <pre><code>drutiny profile:run --format=html -f csv &lt;profile:name&gt; &lt;target&gt;\n</code></pre> <p>To place a report in a predefined folder, speific the folder name with the <code>-o</code>  or <code>--report-dir</code> option.</p> <pre><code>drutiny profile:run -f json -o reports/ &lt;profile:name&gt; &lt;target&gt;\n</code></pre>"},{"location":"Usage/Profile/#setting-reporting-periods","title":"Setting reporting periods","text":"<p>Some policies report on data examined across a time period. For these policies and underlying audit classes, they require a reporting period range. By default, Drutiny sets the reporting period as the last 24 hours. For larger reporting periods you can use the <code>--reporting-period-start</code> and <code>--reporting-period-end</code> options. Alternatively, you can provide the entire period using <code>--reporting-period</code>.</p> <pre><code># Report on the last 7 days\ndrutiny profile:run &lt;profile:name&gt; &lt;target&gt; -f html --reporting-period-start='-7 days'\n\n# Reporting on an absolute time period.\ndrutiny profile:run &lt;profile:name&gt; &lt;target&gt; -f html --reporting-period-start='2021-01-01 00:00:00' --reporting-period-end='2021-02-01 00:00:00'\n\n# Using the reporting period syntax.\ndrutiny profile:run &lt;profile:name&gt; &lt;target&gt; -f html --reporting-period='01/01/2021 00:00:00 to 01/02/2021 00:00:00'\n</code></pre>"},{"location":"Usage/Profile/#including-and-excluding-policies-from-a-profile","title":"Including and excluding policies from a profile","text":"<p>If a profile contains a policy to which to omit from the report, or is missing a policy you'd like to include in the report, you can use the the include and exclude policy options.</p> <pre><code>drutiny profile:run --include-policy=&lt;policy:name&gt; --exclude-policy=&lt;policy:name&gt; &lt;profile:name&gt; &lt;target&gt; -f csv\n</code></pre>"},{"location":"Usage/Profile/#setting-default-reports-directory","title":"Setting default reports directory","text":"<p>You can use the <code>--report-dir</code> (<code>-o</code>) option to specify where any report formats should be written to.</p> <pre><code>drutiny profile:run &lt;profile:name&gt; &lt;target&gt; -f html -o &lt;path-to-reports-dir&gt;\n</code></pre> <p>Alternatively you can also set an environment variable called <code>DRUTINY_REPORT_DIR</code> and Drutiny will default to this location</p> <pre><code>export DRUTINY_REPORT_DIR=$HOME/Reports\ndrutiny profile:run &lt;profile:name&gt; &lt;target&gt; -f html # Places HTML report in $DRUTINY_REPORT_DIR\n</code></pre>"},{"location":"Usage/Setup/","title":"Setup","text":"<p>Drutiny can operate out-of-the-box. However some plugins may require setup and you may have local configuration you might like to make.</p>"},{"location":"Usage/Setup/#plugins","title":"Plugins","text":"<p>Some plugins require configuration or credentials to work effectively. To set these plugins up, you'll need to run the <code>plugin:setup &lt;plugin&gt;</code> command and provide the required credentials.</p> <p>Use <code>plugin:list</code> to view a list of available plugins and if they've been installed yet or not. To install the plugin, simply run <code>plugin:setup</code> with the <code>namespace</code> value as the <code>&lt;plugin&gt;</code> argument.</p> <pre><code>drutiny plugin:setup &lt;plugin:namespace&gt;\n</code></pre> <p>If a plugin is already setup, you can view the configuration details by using <code>plugin:view &lt;plugin:namespace&gt;</code>.</p>"},{"location":"Usage/Setup/#configuration","title":"Configuration","text":"<p>Drutiny manages configuration using a file called <code>drutiny.yml</code>. Any plugins or projects using Drutiny may provide their own <code>drutiny.yml</code> file. You can override Drutiny's default configuration by creating a <code>drutiny.yml</code> file and overwriting any value.</p>"},{"location":"Usage/Setup/#parameters","title":"Parameters","text":"Configuration Default Value Description drutiny_config_dir '%user_home_dir%/.drutiny' Where to store drutiny config and credentials. policy.library.fs '%drutiny_config_dir%/policy' Where to look for localfs policies cache.directory '%drutiny_config_dir%/cache' Where to store cached items cache.ttl 3600 TTL For cached items config.local '%drutiny_config_dir%/config.yml' Where config is stored config.credentials '%drutiny_config_dir%/.credentials.yml' Where credentials are stored config.old_path '%drutiny_config_dir%/.drutiny_creds.yml' The location for drutiny 2.x credentials. log.directory '%user_home_dir%/.drutiny/logs' Where the logs from drutiny are written too. log.name drutiny The namespace for the logs log.filepath '%log.directory%/%log.name%.log' The filepath of for the log file log.level WARNING The log level to log and above. log.max_files 20 The maximum number of files before they are rotated. twig.templates ['%drutiny_core_dir%/twig', '%drutiny_core_dir%/twig/report'] Locations hwere to find twig templates. twig.cache '%drutiny_config_dir%/twig' Location where to find twig cache. twig.debug true Turn on twig debugging. twig.strict true Whether twig is strict or relazed. async.forks 7 Max number of forks to run in parallel language_default en The default language to operate in. progress_bar.template %%message%%\\n%%current%%/%%max%% [%%bar%%] %%percent:3s%%%% %%elapsed:6s%% The template to use for the progress bar."},{"location":"Usage/Setup/#language-support","title":"Language support","text":"<p>Drutiny is written in english but supports the ability for policies and profiles to be provided in any language. This can be done with the <code>--language</code> option on any language aware command in Drutiny.</p> <pre><code># List Spanish policies.\ndrutiny policy:list --language=es\n\n# List German profiles\ndrutiny profile:list --language=de\n\n# Execute a policy audit with a Japanese policy.\ndrutiny policy:audit &lt;policy_name&gt; &lt;target&gt; --language=ja\n\n# Execute a profile audit in Spanish.\ndrutiny profile:run &lt;profile_name&gt; &lt;target&gt; --language=es\n</code></pre> <p>Note: The policy and profile sources you use must provide the policies and profiles you wish to use in the language you wish to use. You cannot use a language that no sources provide support for.</p> <p>If you wish to work exclusively with a non-english language you can set your default language to the language code of your choice which will allow you to omit the use of the <code>--language</code> paramenter.</p> <p>Edit <code>drutiny.yml</code> and set the <code>language_default</code> parameter to your preferred language code.</p> <pre><code>parameters:\n  # Default language to Japanese.\n  language_default: ja\n</code></pre>"},{"location":"Usage/Target/","title":"Target Usage","text":"<p>Targets are objects Drutiny audits policies against. Drutiny supports targets of multiple types. Drutiny comes with two default targets: NullTarget and DrushTarget.</p> <p>Additional targets can be added by plugins.</p>"},{"location":"Usage/Target/#discover","title":"Discover","text":"<p>To discover your available targets, run <code>target:sources</code> to list the targets sources and use <code>target:list &lt;source&gt;</code> to list targets available from a given source.</p> <pre><code>drutiny target:sources\n</code></pre> <pre><code>drutiny target:list &lt;source&gt;\n</code></pre> <p>From the list provided in <code>target:list &lt;source&gt;</code> you'll be able to select a target to audit a policy against with <code>policy:audit</code> or run a profile against with <code>profile:run</code>.</p>"},{"location":"Usage/Target/#getting-information-about-the-target","title":"Getting information about the target.","text":"<p>When a target loads, the target source makes available additional metadata about the target. This information is not particularly useful in general usage of Drutiny (such as running profiles or policy audits) but knowing what information is available on a target is very useful when building a policy, audit or your own target class.</p> <pre><code>drutiny target:info &lt;target&gt;\n</code></pre>"}]}